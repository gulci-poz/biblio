# rypress.com/tutorials/git/index
# https://www.atlassian.com/git/tutorials/
# https://git-scm.com/book/en/v2

# śledzenie zdalnej gałęzi
# --set-upstream jest deprecated
git push | pull -u github master

# dodaje do .gitignore
git rm --cached .idea -r
git rm --cached __pycache__ -r

# list zdalnych repozytoriów
git remote
# verbose
git remote -v

# pobranie zmian, bez wdrożenia na system plików, obie te rzeczy robi git pull
git fetch

# wyświetla gałęzie
git branch
# dla każdego błędu tworzymy nową gałąź

# przełączenie z utworzeniem nowej gałęzi (-b)
git checkout -b test1
# lub samo utworzenie gałęzi
git branch test1

# przejście do gałęzi
git checkout master

# push do nowej gałęzi - nowa gałąź zostanie utworzona w zdalnym repo
git push -u github test1
# w przypadku pull nowa gałąź jest tworzona lokalnie
git pull github test1
# przy checkout automatycznie zostanie ustawiony tracking

# w master mamy kod produkcyjny, nie powinno się z niego korzystać
# gałęzie są tworzone od aktywnej gałęzi

# jeśli użyjemy id issue, np. #1, to w liście issue będziemy mieli zaznaczone,
# że dany commit robił referencję do issue

# używamy git flow do ogarnięcia gałęzi
sudo apt-get install git-flow
git flow init

# możemy zrobić ręcznie merge
# jesteśmy na master
git merge test1
# jeśli nie ma konfliktów, to automatycznie kopiowane są commity z mergowanej gałęzi
# jeśli jest konflikt, to po wprowadzeniu poprawek robimy commit
# w przypadku pull request możemy mergować w githubie

# gałąź test1 pozostaje w repo, możemy dalej z niej korzystać

# kasowanie gałęzi
git branch -d <name>
# jeśli gałąź nie jest zmergowana, to musimy potwierdzić jej usunięcie
git branch -D <name>

# wypchnięcie wszystkich gałęzi
git push --all

==================================================

pip install "django==1.10.6"
pip install "django>=1.10,<1.11"
pip search django

w django mamy MTV - Model, Template, View
View wyciąga dane z Model i przygotowuje do wyświetlania w Template
Template jest odpowiednikiem MVC.View
View analizuje ścieżkę URL i poprzez View wyciąga Model

./manage.py migrate
./manage.py runserver (możemy to robić na screen)

każdy projekt jest tak naprawdę aplikacją
projekt jest nadrzędnym bytem (np. cała strona, witryna)

jedna aplikacja - jedno zadanie; dużo małych aplikacji
./manage.py startapp

admin.py
konfiguracja panelu administratora, podłączenia modeli

migrations
zmiany modeli w bazie

models.py
definiujemy jak będą wyglądały obiekty w bazie danych

test.py
testy

views.py
realizacja części View

w py3 nie trzeba w ogóle informować o kodowaniu, wszystkie pliki są w UTF-8

sqlite3 db.sqlite3
.schema
pokazuje tebele dla sqlite

po dodaniu modelu danych w models.py trzeba dodać aplikację shelf w settings.py (INSTALLED_APPS)
robimy schema migration, informacje o zmianie struktury bazy są przechowywane w plikach w folderze migrations
./manage.py makemigrations
migracji można nadać nazwę używając --name
sychronizacja bazy danych z obecnymi modelami i migracjami (anjpierw synchronizuje niezmigrowane aplikacje, robi to samo co syncdb, a potem przeprowadza migracje, które jeszcze nie zostały przeprowadzone)
./manage.py migrate

migracje danych robimy przygotowując pusty plik migracji (makemigrations) i po uzupełnieniu robimy migrację (migrate), synchronizacja danych zostanie wykonana automatycznie z sychronizacją bazy

jeśli mamy zmianę typu pola, to lepiej zrobić nowe pole z nowym typem niż dawać nowy typ do istniejącego pola (u nas np. zmiana author na authors); koniecznie jeśli mamy zmianę typów relacyjnych np. ForeignKey na ManyToManyField, mniej ważne przy zmianie danych numerycznych i tekstowych

./manage.py createsuperuser

rejestrujemy model w admin.py

mamy dostęp do shella django
./manage.py shell
django rozpoznaje, że jest ipython i automatycznie się do niego przełącza
możemy przeglądać modele (przyda się potem przy zapytaniach do db)
from shelf.models import Author
Author.objects.all()

django guardian - aplikacja do nadawania uprawnień do obiektów

dołączam model do widoku w views.py i zapisuję url do widoku w urls.py
szablony

przechodzi całe drzewo projektu i wyciąga stringi do translacji, tworzy lub uaktualnia plik message; trzeba samemu utworzyć folder locale
./manage.py makemessages -l pl
dostajemy plik .po (Portable Object)
jeśli tego nie zrobiliśmy po dodaniu funkcji _ (ugettext_lazy), to teraz trzeba
./manage.py makemigrations
./manage.py migrate
trzeba dodać LOCALE_PATH do settings.py
django-admin compilemessages
dostajemy plik .mo (top level locale)
plik binarny zoptymalizowany do użycia przez ugettext_lazy
aplikacje:poedit (sudo dnf install pootle)
pootle (napisany w django, działa w py2, wymaga import pootle)

użycie shell:
from shelf.models import Author, Book, BookItem, BookEdition, BookCategory, Publisher
Author.objects.all()
autor = Author()
autor.first_name = "Mario"
autor.last_name = "Vargas Llosa"
autor.save()
autor.id
(autor.pk)
#dopóki obiekt nie jest zapisany w bazie, to nie ma id; sposób na sprawdzenie obecności modelu (obiektu, nazywa go też modelem) w bazie
a = Author(first_name = "Juliusz", last_name = "Verne")
a.save()
a2 = Author.objects.create()
#stworzyliśmy obiekt, który został dodany do bazy, ale ma puste pola
a2.id
a2.first_name
#id pozostanie zajęte
a2.delete()
a2 = Author.objects.create(first_name = "Henryk", last_name = "Sienkiewicz")
#atrybut objects jest powiązany z managerem obiektów, sposób na dostanie się do bazy danych
#tutaj zostało wykonane zapytanie
Author.objects.all()
#tutaj nie
value = Author.objects.all()
type(value)
#dostajemy QuerySet, typ leniwy, pośrednik w dostępnie do bazy
#teraz dopiero poszło zapytanie do bazy
value.filter(last_name__contains = "wicz")
#dodawanie autorów do ManyToMany (jak zrobić w dj w panelu adm. szukanie search_fields po ManyToMany?)
ac1 = Author(first_name = "Brian", last_name = "Kernighan")
ac1.save()
ac2 = Author(first_name = "Dennis", last_name = "Ritchie")
ac2.save()
#nie możemy pod authors podstawić autora (obiektu), może uda się listę?
book = Book.objects.create(title = "Język C")
#tu mamy relację
book.authors
#tu się dowiadujemy, że mamy pustą listę
book.authors.all()
book.authors.add(ac1)
book.authors.add(ac2)
book.save()
#nowa sesja + import
b = Book.objects.all().last()
b
b.authors.all()
