# rypress.com/tutorials/git/index
# https://www.atlassian.com/git/tutorials/
# https://git-scm.com/book/en/v2

# śledzenie zdalnej gałęzi
# --set-upstream jest deprecated
git push -u github master

# dodaje do .gitignore
git rm --cached .idea -r
git rm --cached __pycache__ -r

# list zdalnych repozytoriów
git remote
# verbose
git remote -v

# pobranie zmian, bez wdrożenia na system plików, obie te rzeczy robi git pull
git fetch

# wyświetla gałęzie
git branch
# dla każdego błędu tworzymy nową gałąź

# przełączenie z utworzeniem nowej gałęzi (-b)
git checkout -b test1
# lub samo utworzenie gałęzi
git branch test1

# przejście do gałęzi
git checkout master

# push do nowej gałęzi - nowa gałąź zostanie utworzona w zdalnym repo
git push -u github test1
# w przypadku pull nowa gałąź jest tworzona lokalnie
git pull github test1
# przy checkout automatycznie zostanie ustawiony tracking

# w master mamy kod produkcyjny, nie powinno się z niego korzystać
# gałęzie są tworzone od aktywnej gałęzi

# jeśli użyjemy id issue, np. #1, to w liście issue będziemy mieli zaznaczone,
# że dany commit robił referencję do issue

# używamy git flow do ogarnięcia gałęzi
sudo apt-get install git-flow
git flow init

# możemy zrobić ręcznie merge
# jesteśmy na master
git merge test1
# jeśli nie ma konfliktów,
# to automatycznie kopiowane są commity z mergowanej gałęzi
# jeśli jest konflikt, to po wprowadzeniu poprawek robimy commit
# w przypadku pull request możemy mergować w githubie

# gałąź test1 pozostaje w repo, możemy dalej z niej korzystać

# kasowanie gałęzi
git branch -d <name>
# jeśli gałąź nie jest zmergowana, to musimy potwierdzić jej usunięcie
git branch -D <name>

# wypchnięcie wszystkich gałęzi
git push --all

==================================================

pip install "django==1.10.6"
pip install "django>=1.10,<1.11"
pip search django

w django mamy MTV - Model, Template, View
View wyciąga dane z Model
i przygotowuje do wyświetlania za pomocą wzorca Template
Template jest odpowiednikiem MVC.View
View analizuje ścieżkę URL

projekt jest nadrzędnym bytem (np. cała strona, witryna)
projekt to również aplikacja
jedna aplikacja - jedno zadanie; dużo małych aplikacji

sqlite3 db.sqlite3
.schema
pokazuje tebele dla sqlite

w momencie utworzenia klasy modelu mamy dostępny obiekt danych z jego metodami
migracji można nadać nazwę używając --name

jeśli mamy zmianę typu pola, to lepiej zrobić nowe pole z nowym typem
niż dawać nowy typ do istniejącego pola

koniecznie jeśli mamy zmianę typów relacyjnych,
np. ForeignKey na ManyToManyField,
mniej ważne przy zmianie danych numerycznych i tekstowych

manage.py shell
from shelf.models import Author
Author.objects.all()

django guardian - aplikacja do nadawania uprawnień do obiektów

dołączam model do widoku w views.py i zapisuję url do widoku w urls.py
w przypadku widoków generycznych widok przekazuje dane do szablonu
pod zmienną object_list lub object (detail)
grupę przekazanych do szablonu zmiennych nazywamy kontekstem
w przypadku widoków generycznych nazwa przekazanego z urla pola
musi być oznaczona pk lub slug (nie id)
funkcja .as_view() zwraca funkcję widoku

formularz jest domyślnie przekazywany do szablonu pod zmienną form
formularz jest domyślnie wyświetlany jako tabela
(za pomocą funkcji .as_table(), można też użyć .as_p();
w shellu robimy wywołanie funkcji, w szablonie piszemy tylko form.as_p)

przechodzi całe drzewo projektu i wyciąga stringi do translacji, tworzy lub uaktualnia plik message; trzeba samemu utworzyć folder locale
./manage.py makemessages -l pl
dostajemy plik .po (Portable Object)
jeśli tego nie zrobiliśmy po dodaniu funkcji _ (ugettext_lazy), to teraz trzeba
./manage.py makemigrations
./manage.py migrate
trzeba dodać LOCALE_PATH do settings.py
django-admin compilemessages
dostajemy plik .mo (top level locale)
plik binarny zoptymalizowany do użycia przez ugettext_lazy
aplikacje:poedit (sudo dnf install pootle)
pootle (napisany w django, działa w py2, wymaga import pootle)

użycie shell:
from shelf.models import Author, Book, BookItem, BookEdition, BookCategory, Publisher
Author.objects.all()
autor = Author()
autor.first_name = "Mario"
autor.last_name = "Vargas Llosa"
autor.save()
autor.id
(autor.pk)
#dopóki obiekt nie jest zapisany w bazie, to nie ma id; sposób na sprawdzenie obecności modelu (obiektu, nazywa go też modelem) w bazie
a = Author(first_name = "Juliusz", last_name = "Verne")
a.save()
a2 = Author.objects.create()
#stworzyliśmy obiekt, który został dodany do bazy, ale ma puste pola
a2.id
a2.first_name
#id pozostanie zajęte
a2.delete()
a2 = Author.objects.create(first_name = "Henryk", last_name = "Sienkiewicz")
#atrybut objects jest powiązany z managerem obiektów, sposób na dostanie się do bazy danych
#tutaj zostało wykonane zapytanie
Author.objects.all()
#tutaj nie
value = Author.objects.all()
type(value)
#dostajemy QuerySet, typ leniwy, pośrednik w dostępnie do bazy
#teraz dopiero poszło zapytanie do bazy
value.filter(last_name__contains = "wicz")
#dodawanie autorów do ManyToMany (jak zrobić w dj w panelu adm. szukanie search_fields po ManyToMany?)
ac1 = Author(first_name = "Brian", last_name = "Kernighan")
ac1.save()
ac2 = Author(first_name = "Dennis", last_name = "Ritchie")
ac2.save()
#nie możemy pod authors podstawić autora (obiektu), może uda się listę?
book = Book.objects.create(title = "Język C")
#tu mamy relację
book.authors
#tu się dowiadujemy, że mamy pustą listę
book.authors.all()
book.authors.add(ac1)
book.authors.add(ac2)
book.save()
#nowa sesja + import
b = Book.objects.all().last()
b
b.authors.all()
